
# Form implementation generated from reading ui file 'display.ui'
#
# Created by: PyQt6 UI code generator 6.6.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.

import socket

import time
from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtCore import QCoreApplication
# from bluetooth import Protocols
import bluetooth
import sys
from time import sleep
from PyQt6.QtWidgets import QApplication, QMainWindow, QSizePolicy, QVBoxLayout, QWidget, QPinchGesture, QGraphicsView, QGraphicsScene, QGraphicsPixmapItem, QMessageBox, QDialog, QInputDialog, QTableWidgetItem, QTextEdit
from PyQt6.QtGui import QPixmap, QPainter,QFont
from PyQt6.QtCore import QObject, QThread, pyqtSignal, Qt,QEvent, QPoint, QPointF  
import display,search
from PyQt6.QtWidgets import (
    QDateTimeEdit,QSpinBox, QLineEdit, QTimeEdit,QVBoxLayout,QMessageBox, QComboBox, QDialogButtonBox,QLabel, QPushButton, QCalendarWidget)
from PyQt6.QtCore import QDateTime, Qt
import mysql.connector



class PhotoViewer(QtWidgets.QGraphicsView):
    photoClicked = QtCore.pyqtSignal(QtCore.QPointF)

    def __init__(self, parent):
        super(PhotoViewer, self).__init__(parent)
        self._zoom = 0
        self.shown = False
        self._empty = True
        self._scene = QtWidgets.QGraphicsScene(self)
        self._photo = QtWidgets.QGraphicsPixmapItem()
        self._scene.addItem(self._photo)
        self.grabGesture(Qt.GestureType.PinchGesture)
        self.setScene(self._scene)
        self.setTransformationAnchor(
            QtWidgets.QGraphicsView.ViewportAnchor.AnchorUnderMouse)
        self.setResizeAnchor(
            QtWidgets.QGraphicsView.ViewportAnchor.AnchorUnderMouse)
        self.setVerticalScrollBarPolicy(
            QtCore.Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setHorizontalScrollBarPolicy(
            QtCore.Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setBackgroundBrush(QtGui.QBrush(QtGui.QColor(30, 30, 30)))
        self.setFrameShape(QtWidgets.QFrame.Shape.NoFrame)

    def event(self,event):
        if event.type() == QEvent.Type.Gesture:
            gesture = event.gesture(Qt.GestureType.PinchGesture)
            # print(gesture)
            if gesture:
                self.handle_pinch(gesture)
                return True
        return super().event(event)

    def handle_pinch(self, gesture):
        scale_factor = gesture.scaleFactor()
        if(scale_factor>1):
            self._zoom +=(scale_factor-1)
        else:
            self._zoom -=(1-scale_factor)
        if self._zoom > 0:
            self.scale(scale_factor,scale_factor)
        else:
            self.fitInView()
        print(scale_factor)

    def hasPhoto(self):
        return not self._empty

    def showEvent(self, event):
        super().showEvent(event)
        if not self.shown:
            self.shown = True
            # self.fitInView()
    def fitInView(self, scale=True):
        rect = QtCore.QRectF(self._photo.pixmap().rect())
        if not rect.isNull():
            self.setSceneRect(rect)
            if self.hasPhoto():
                unity = self.transform().mapRect(QtCore.QRectF(0, 0, 1, 1))
                self.scale(1 / unity.width(), 1 / unity.height())
                viewrect = self.viewport().rect()
                scenerect = self.transform().mapRect(rect)
                factor = min(viewrect.width() / scenerect.width(),
                             viewrect.height() / scenerect.height())
                print(viewrect)
                print(scenerect)
                print(unity)
                self.scale(factor, factor)
                pass
            self._zoom = 0

    def setPhoto(self, pixmap=None):
        self._zoom = 0
        if pixmap and not pixmap.isNull():
            self._empty = False
            self.setDragMode(QtWidgets.QGraphicsView.DragMode.ScrollHandDrag)
            self._photo.setPixmap(pixmap)
        else:
            self._empty = True
            self.setDragMode(QtWidgets.QGraphicsView.DragMode.NoDrag)
            self._photo.setPixmap(QtGui.QPixmap())
        self.fitInView()

    def wheelEvent(self, event):
        if self.hasPhoto():
            if event.angleDelta().y() > 0:
                factor = 1.25
                self._zoom += 1
            else:
                factor = 0.8
                self._zoom -= 1
            if self._zoom > 0:
                self.scale(factor, factor)
            elif self._zoom <= 0:
                self.fitInView()
            else:
                self._zoom = 0

    def toggleDragMode(self):
        if self.dragMode() == QtWidgets.QGraphicsView.DragMode.ScrollHandDrag:
            self.setDragMode(QtWidgets.QGraphicsView.DragMode.NoDrag)
        elif not self._photo.pixmap().isNull():
            self.setDragMode(QtWidgets.QGraphicsView.DragMode.ScrollHandDrag)

    def mousePressEvent(self, event):
        if self._photo.isUnderMouse():
            self.photoClicked.emit(self.mapToScene(event.position().toPoint()))
        super(PhotoViewer, self).mousePressEvent(event)

class Worker(QObject):
    finished = pyqtSignal()
    progress = pyqtSignal(str)

    def run(self):
        """Long-running task."""
        print("Đang tìm kiếm các thiết bị Bluetooth xung quanh...")
        nearby_devices = bluetooth.discover_devices(duration=8, lookup_names=True, flush_cache=True)
        print("Các thiết bị Bluetooth xung quanh:")
        for addr, name in nearby_devices:
            # self.device_list.addItem(f"{addr} - {name}")
            self.progress.emit(f"{addr} - {name}")
            print(f"{addr} - {name}")
        self.finished.emit()
    def connect(self,id):
        option = id
        device_address = option[:17]
        port = 1  # RFCOMM port number
        # try:
        print(f"Đang kết nối đến thiết bị có địa chỉ {device_address}...")
        sock = bluetooth.BluetoothSocket(socket.BTPROTO_RFCOMM)
        sock.connect((device_address, port))
        while(1):
            pass
        self.finished.emit()
        # except Exception as e:
        #     print("Kết nối thất bại")
        #     return None

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.uic = display.Ui_MainWindow()
        self.uic.setupUi(self)
        self.viewer = PhotoViewer(self)
        self.uic.image_layout.addWidget(self.viewer)
        self.viewer.setPhoto(QtGui.QPixmap('test.jpg'))
        self.thread = {}
        self.grabGesture(Qt.GestureType.PinchGesture)
        self.uic.connect_button.clicked.connect(self.connect)
        self.uic.cancel_button.clicked.connect(self.cancel_connection)
        self.uic.device_list.setPlaceholderText( "Danh sách thiết bị Bluetooth")
        self.uic.device_list.activated.connect(self.device_list_select)
        self.uic.cancel_button.setStyleSheet("background-color: #66CDAA; color: white;")
        self.uic.quitbutton.clicked.connect(self.exit)
        self.uic.minbutton.clicked.connect(self.minimize_window)
        self.uic.maxbutton.clicked.connect(self.maximize_window)
        self.uic.search_button.clicked.connect(self.search_information)
        self.uic.bground.setStyleSheet("background-color: #949084; color: white;")
        self.uic.bground.setText("Thiết bị truy cập trực tiếp máy bắn tốc độ - SPR Lab")
        self.uic.connect_with_mac.setText("Kết nối tới địa chỉ")
        self.uic.connect_with_mac.clicked.connect(self.connect_with_address)
        self.uic.information_button.clicked.connect(self.show_information)
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.showMaximized()
        self.viewer.fitInView()
        # self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground) 
        self.uic.bground.setDisabled(True)
        self.uic.bground.mouseMoveEvent = self.MoveWindow
        self.uic.bground.mousePressEvent = self.mousePressEvent
        self.clickPosition = QPoint()
        self.setWindowTitle("Hệ thống xử lý vi phạm tốc độ")
        self.setWindowIcon(QtGui.QIcon("icon/csgt.png"))

        self.setIcon("icon/min2.png", self.uic.minbutton)
        self.setIcon("icon/connect_with_mac.png", self.uic.connect_with_mac, icon_size=(30, 35))  # Kích thước tùy chỉnh
        self.setIcon("icon/quit.png", self.uic.quitbutton, icon_size=(30, 35))  # Kích thước tùy chỉnh
        self.setIcon("icon/min.png", self.uic.maxbutton, icon_size=(30, 35))
        self.setIcon("icon/search.png", self.uic.search_button, icon_size=(30, 35))
        self.setIcon("icon/accept.png", self.uic.accept_button)
        self.setIcon("icon/deny.png", self.uic.deny_button)
        self.setIcon("icon/bluetooth.png", self.uic.connect_button)
        self.setIcon("icon/in4.png", self.uic.information_button,icon_size=(30, 35))


        
    
        self.image = QPixmap("test.jpg")
        self.uic.image_label.setPixmap(self.image)
        self.uic.image_label.setSizePolicy(QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Ignored)
        self.uic.image_label.setScaledContents(True)

        self.uic.device_list.setDisabled(1)
        self.uic.accept_button.setDisabled(0)
        self.uic.accept_button.clicked.connect(self.accept_information)

        self.uic.deny_button.setDisabled(1)
        # notice=QMessageBox()
        # notice.setWindowTitle("Thông báo")
        # notice.setText("Bạn đã từ chối bản tin")
        # notice.setIcon(QMessageBox.Icon.Information)
        # notice.setStyleSheet(
        #     "QLabel { margin-left: 5px; font-size: 20px; } QPushButton{ width:100px; font-size: 15px; }" 
        # )
        # notice.exec()
        self.uic.instruction_text.setText("Sau khi nhận được bản tin, người sử dụng có hai lựa chọn:\n- Nhấn nút 'Gửi lên Server' (nút màu xanh) nếu chấp nhận bản tin đạt chuẩn và muốn gửi lên Server.\n- Nhấn nút 'Chụp lại ảnh mới' (nút màu đỏ) nếu hình ảnh chưa đạt chuẩn và yêu cầu Máy bắn tốc độ chụp lại ảnh mới.\n\n")
        self.uic.instruction_text.setStyleSheet("font-size: 14pt;")
        self.uic.instruction_text.setDisabled(1)
        self.show_info_in_text_edit()


    def show_info_in_text_edit(self):
        info = """
        Tên người vi phạm: Phạm Quốc Huy
        Loại phương tiện: Ô tô
        Biển kiểm soát: 18B-22212
        Tốc độ vi phạm: 70km/h
        Giới hạn tốc độ quy định: 50km/h
        Thời điểm ghi nhận: 08/05/2024 R:35
        Vị trí ghi nhận: 
                  Vĩ độ: 11° 29' 24'' Bắc
                  Kinh độ: 109° 27' 36'' Đông
                  Vị trí Km480-900
                  QL1A-Hà Nội
        Thiết bị: 01012 Kiểm định đến 10_2020
        Đơn vị vận hành: Phòng Cảnh sát Giao thông Công an tỉnh Hà Nội
        """
        
        html_content = self.format_text_with_colors(info)
        
        self.uic.textEdit.setHtml(html_content)
        self.uic.textEdit.setStyleSheet("font-size: 16pt;")
        self.uic.textEdit.setReadOnly(True)

    def format_text_with_colors(self,text):
        lines = text.split('\n')
        formatted_lines = []
        
        for line in lines:
            if "Biển kiểm soát:" in line:
                formatted_lines.append(f'<p><strong>Biển kiểm soát:</strong> <span style="color:red;">{line.split(":", 1)[1].strip()}</span></p>')
            elif "Tốc độ vi phạm:" in line:
                formatted_lines.append(f'<p><strong>Tốc độ vi phạm:</strong> <span style="color:red;">{line.split(":", 1)[1].strip()}</span></p>')
            elif "Vị trí ghi nhận:" in line:
                formatted_lines.append(f'<p><strong>Vị trí ghi nhận:</strong></p>')
            elif "Vĩ độ:" in line or "Kinh độ:" in line or "Vị trí" in line or "QL1A-Hà Nội" in line:
                formatted_lines.append(f'<p style="color:blue;">{line.strip()}</p>')
            elif "Thiết bị:" in line:
                formatted_lines.append(f'<p><strong>Thiết bị:</strong> <span style="color:blue;">{line.split(":", 1)[1].strip()}</span></p>')
            elif "Đơn vị vận hành:" in line:
                formatted_lines.append(f'<p><strong>Đơn vị vận hành:</strong> <span style="color:blue;">{line.split(":", 1)[1].strip()}</span></p>')
            else:
                formatted_lines.append(f'<p>{line.strip()}</p>')
        
        return '\n'.join(formatted_lines)

    def show_information(self):
        # Tạo thông báo với hướng dẫn
        instructions = (
            "1. Nhấn nút 'Bật Bluetooth' để bắt đầu quét các thiết bị Bluetooth xung quanh. Sau khi quá trình quét hoàn tất, "
            "các thiết bị Bluetooth nhận diện được sẽ hiển thị trong 'Danh sách thiết bị Bluetooth'. Nếu thiết bị mong muốn "
            "không xuất hiện trong danh sách, bạn có thể kết nối trực tiếp bằng cách nhập địa chỉ MAC của thiết bị và nhấn nút 'Kết nối bằng địa chỉ MAC'.\n\n"
            "2. Trong trường hợp kết nối thất bại, hãy thử kết nối lại. Khi kết nối thành công, chờ thiết bị Máy bắn tốc độ gửi bản tin.\n\n"
            "3. Sau khi nhận được bản tin, người sử dụng có hai lựa chọn:\n"
            "   - Nhấn nút 'Gửi lên Server' (nút màu xanh) nếu chấp nhận bản tin đạt chuẩn và muốn gửi lên Server.\n"
            "   - Nhấn nút 'Chụp lại ảnh mới' (nút màu đỏ) nếu hình ảnh chưa đạt chuẩn và yêu cầu Máy bắn tốc độ chụp lại ảnh mới.\n\n"
            "4. Ngoài ra, người dùng có thể nhấn nút 'Tìm kiếm' để tìm kiếm và xem lại các bản tin đã được xác nhận."
        )

        dialog = QDialog(self)
        dialog.setWindowTitle("Hướng dẫn sử dụng")
        dialog.resize(600, 400)  # Đặt kích thước của QDialog

        text_edit = QTextEdit()
        text_edit.setText(instructions)
        text_edit.setReadOnly(True)
        text_edit.setStyleSheet("font-size: 16px;")  # Điều chỉnh cỡ chữ ở đây

        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok)
        button_box.accepted.connect(dialog.accept)

        # Thiết lập kích thước nút Ok
        ok_button = button_box.button(QDialogButtonBox.StandardButton.Ok)
        ok_button.setFixedSize(60, 30)  # Đặt kích thước nút Ok

        layout = QVBoxLayout()
        layout.addWidget(text_edit)
        layout.addWidget(button_box)

        dialog.setLayout(layout)
        dialog.exec()


    def setIcon(self, icon_path, ui_element, icon_size=(25, 30)):
        """
        Đặt icon cho một phần tử giao diện PyQt6.

        :param icon_path: Đường dẫn tới tệp hình ảnh cho icon.
        :param ui_element: Phần tử giao diện (ví dụ, nút hoặc QLabel) cần đặt icon.
        :param icon_size: Kích thước của icon (rộng, cao). Mặc định là (25, 30).
        """
        icon = QtGui.QIcon()  # Tạo một đối tượng QIcon
        pixmap = QtGui.QPixmap(icon_path)  # Tạo QPixmap từ đường dẫn hình ảnh
        icon.addPixmap(pixmap, QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)  # Thêm pixmap vào icon

        ui_element.setIcon(icon)  # Đặt icon cho phần tử giao diện
        ui_element.setIconSize(QtCore.QSize(*icon_size))  # Đặt kích thước icon
        
    def dialog_config(self, dialog, dialog_text, callback_function):
        dialog.setWindowTitle(dialog_text)
        dialog.resize(300, 50)  # Đặt kích thước cho cửa sổ pop-up

        # Thêm một QLineEdit để nhập giá trị tên vào dialog
        line_edit = QLineEdit(dialog)

        # Thêm một QPushButton vào dialog
        btn_ok = QPushButton('OK', dialog)

        # Bố trí các thành phần trong dialog bằng QVBoxLayout
        layout = QVBoxLayout()
        layout.addWidget(QLabel(dialog_text))
        layout.addWidget(line_edit)
        layout.addWidget(btn_ok)

        # Xử lý sự kiện khi nhấn nút "OK"
        def showValue():
            value = line_edit.text()
            callback_function(value)
            dialog.close()

        btn_ok.clicked.connect(showValue)

        dialog.setLayout(layout)

    def connect_with_address(self):
        # Tạo một QDialog để hiển thị pop-up
        dialog = QDialog(self)
        def callback_function(device_address):
            self.thread[2] = ThreadClass(index=1,mac_id=device_address)
            self.thread[2].start()
            self.thread[2].signal.connect(self.my_function)
            self.thread[2].connect_status.connect(self.status_change)

        self.dialog_config(dialog, "Nhập địa chỉ thiết bị bạn muốn kết nối", callback_function)
        # Hiển thị dialog
        dialog.exec()
        
    def accept_information(self):
        with open('test.txt', 'r') as file:
            merge_text = file.read()
            if "Phong Canh sat" in merge_text:
                merge_text = merge_text.replace("Phong Canh sat Giao thong", "Phong Canh sat Giao thong\n")
        # Đọc hình ảnh và thêm khoảng trắng bên phải
        image = QPixmap("test.jpg")
        width = image.width()
        height = image.height()
        new_width = int(width * 1.5)  # Tăng chiều rộng lên 50%
        new_image = QPixmap(new_width, height)
        new_image.fill(Qt.GlobalColor.white)  # Tạo nền trắng mới

        # Vẽ hình ảnh gốc lên hình mới
        painter = QPainter(new_image)
        painter.drawPixmap(0, 0, image)
        painter.end()

        # Chèn văn bản vào phần trắng bên phải
        painter = QPainter(new_image)
        painter.setFont(QFont("Arial", 40))
        painter.drawText(image.width()+30, 0, new_width - image.width(), height, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop, merge_text)
        painter.end()

        # Lưu hình ảnh với text vào file mới
        save_path = "merge.png"
        if save_path:
            new_image.save(save_path)
            QMessageBox.information(self, "LoginOutput", "Update thanh cong")


    def MoveWindow(self, event):
        if not self.isMaximized():
            if event.buttons() & Qt.MouseButton.LeftButton:
                new_position = QPoint(int(event.globalPosition().x() - self.clickPosition.x()),
                                      int(event.globalPosition().y() - self.clickPosition.y()))
                self.move(self.pos() + new_position)
                self.clickPosition = event.globalPosition()
                event.accept()


    def mousePressEvent(self, event):
        self.clickPosition = event.globalPosition()
        event.accept()

    def exit(self):
        # Thực hiện các hành động bạn muốn khi thoát ứng dụng
        QtWidgets.QApplication.quit()

    def minimize_window(self):
        # Minimize cửa sổ
        self.showMinimized()

    def maximize_window(self):
        # Maximize hoặc phục hồi cửa sổ
        if self.isMaximized():
            self.setIcon("icon/max2.png", self.uic.maxbutton, icon_size=(30, 35))
            self.resize(800, 600)
        else:
            self.setIcon("icon/min.png", self.uic.maxbutton, icon_size=(30, 35))
            self.showMaximized()

        

    def wheelEvent(self, event):
        if event.angleDelta().y() > 0:  # Phóng to khi cuộn lên
            self.zoom(1.1)
        else:  # Thu nhỏ khi cuộn xuống
            self.zoom(0.9)

    def zoom(self, factor):
        self.image = self.image.scaled(self.image.size() * factor)
        pixmap = self.image.scaled(self.image.size(), QtCore.Qt.AspectRatioMode.KeepAspectRatio)
        self.uic.image_label.setPixmap(pixmap)


    def device_list_select(self):   
        option = self.uic.device_list.currentText()
        device_address = option[:17]
        self.thread[2] = ThreadClass(index=1,mac_id=device_address)
        self.thread[2].start()
        self.thread[2].signal.connect(self.my_function)
        self.thread[2].connect_status.connect(self.status_change)
    def my_function(self, msg):
        i = self.uic.MainWindow.sender().index
        self.uic.image_label.setText(msg)

    def cancel_connection(self):
        self.thread[2].stop()
        self.uic.connect_button.setMaximumWidth(9999999)
        self.uic.cancel_button.setMaximumWidth(0)

    def status_change(self,status):
        self.uic.connect_button.setDisabled(0)
        self.uic.device_list.setDisabled(0)
        if status>3:
            self.uic.connect_button.setDisabled(1)
            self.uic.device_list.setDisabled(1)
            self.uic.connect_button.setMaximumWidth(9999999)
            self.uic.cancel_button.setMaximumWidth(0)
            self.uic.connect_button.setStyleSheet("background-color: #f7f57c; color: black;")
            self.uic.connect_button.setText("Đang kết nối tới thiết bị")
        if status==1:
            self.uic.connect_button.setMaximumWidth(0)
            self.uic.cancel_button.setMaximumWidth(9999999)
        if status==0:
            self.uic.connect_button.setMaximumWidth(9999999)
            self.uic.cancel_button.setMaximumWidth(0)
        if status==3:
            self.uic.connect_button.setStyleSheet("background-color: #f7917c; color: white;")
            self.uic.connect_button.setText("Kết nối thất bại! Nhấn kết nối lại!")
        # self.thread[2].connect_status.emit(3)

        pass

    def reportProgress(self, n):
        self.uic.device_list.addItem(n)
    def update_device_list_placeholder(self):       
        if self.uic.device_list.count() == 0:
            self.uic.device_list.setPlaceholderText("Không có thiết bị Bluetooth")
        else:
            self.uic.device_list.setPlaceholderText("Danh sách thiết bị Bluetooth")

    def connect(self):
        # Thiết lập màu của nút thành màu xanh
        self.uic.connect_button.setStyleSheet("background-color: #f7f57c; color: black;")
        self.uic.connect_button.setText("Đang quét thiết bị xung quanh...")
        self.uic.connect_button.setDisabled(1)
        QCoreApplication.processEvents()  # Cập nhật giao diện người dùng
        self.uic.device_list.clear() 

        # Step 2: Create a QThread object
        self.thread[1] = QThread()
        # Step 3: Create a worker object
        self.worker = Worker()
        # Step 4: Move worker to the thread
        self.worker.moveToThread(self.thread[1])
        # Step 5: Connect signals and slots
        self.thread[1].started.connect(self.worker.run)
        self.worker.finished.connect(self.thread[1].quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.thread[1].finished.connect(self.thread[1].deleteLater)
        self.worker.progress.connect(self.reportProgress)
        # Step 6: Start the thread
        self.thread[1].start()

        # Final resets
        self.uic.connect_button.setEnabled(False)
        self.thread[1].finished.connect(
            lambda: self.uic.connect_button.setEnabled(True)
        )
        self.thread[1].finished.connect(
            lambda: self.uic.connect_button.setStyleSheet("background-color: #6495ED; color: white;")
        )
        self.thread[1].finished.connect(
            lambda: self.uic.connect_button.setText("Đã bật Bluetooth! Nhấn để quét Bluetooth lại!")
        )
        self.thread[1].finished.connect(
            lambda:  self.uic.device_list.setDisabled(0)
        )
        self.thread[1].finished.connect(
            lambda: self.uic.connect_button.setDisabled(0)
        )
        self.thread[1].finished.connect(self.update_device_list_placeholder)
        # Sau khi tìm thấy các thiết bị, cập nhật lại màu của nút thành màu xanh lá cây
        
    def search_information(self):
        # searchUiDef.show()
        searchUiDef.showMaximized()



class ThreadClass(QtCore.QThread):
    signal = pyqtSignal(str)
    connect_status = pyqtSignal(int)

    def __init__(self, index=0, mac_id = ""):
        super().__init__()
        self.index = index
        self.mac_id = mac_id

    def run(self):
        # print('Starting thread...', self.index,self.mac_id)
        self.connect_status.emit(4)
        counter = 0
            
        try:
            self.connect_status.emit(5)
            client = socket.socket(socket.AF_BLUETOOTH, socket.SOCK_STREAM, socket.BTPROTO_RFCOMM)
            client.connect((self.mac_id, 4))

            # print(f"Connected!")

            self.connect_status.emit(1)
            while True:
                # message = input("Enter message: ")
                # client.send(message.encode('utf-8'))
                data = client.recv(1024)
                if not data:
                    break
                # print(f"Received: {data.decode('utf-8')}")
                # print(self.connect_status)
                self.signal.emit(f"{data.decode('utf-8')}")

        except OSError:
            self.connect_status.emit(3)
            pass

        # print("Disconnected")
        self.connect_status.emit(0)

        client.close()

    def stop(self):
        print('Stopping thread...', self.index)
        self.connect_status.emit(0)
        self.terminate()

class SearchUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.uic = search.Ui_MainWindow()
        self.uic.setupUi(self)
        self.uic.quitbuttonsearch.clicked.connect(self.exit)
        self.uic.minbuttonsearch.clicked.connect(self.minimize_window)
        self.uic.maxbuttonsearch.clicked.connect(self.maximize_window)
        self.setWindowTitle("Cơ sở dữ liệu hệ thống")
        self.setWindowIcon(QtGui.QIcon("icon/Phu_hieu_canh_sat_giao_thong.png"))

        self.uic.byname.clicked.connect(self.searchbyname)
        self.uic.bydate.clicked.connect(self.searchbydate)
        self.uic.bydevice.clicked.connect(self.searchbydevice)
        self.uic.bylocation.clicked.connect(self.searchbylocation)
        self.uic.byplate.clicked.connect(self.searchbyplate)
        self.uic.byspeed.clicked.connect(self.searchbyspeed)
        self.uic.byvehicle.clicked.connect(self.searchbyvehicle)
        self.uic.byid.clicked.connect(self.searchbyid)
        self.uic.showall.clicked.connect(self.showalldatabase)
        self.uic.bystatus.clicked.connect(self.searchbystatus)

        self.setIcon("icon/min2.png", self.uic.minbuttonsearch, icon_size=(30, 35))
        self.setIcon("icon/quit.png", self.uic.quitbuttonsearch, icon_size=(30, 35))  # Kích thước tùy chỉnh
        self.setIcon("icon/min.png", self.uic.maxbuttonsearch, icon_size=(30, 35))
        self.setIcon("icon/database.png", self.uic.showall, icon_size=(30, 35))
        self.setIcon("icon/search.png", self.uic.bgroundsearchby, icon_size=(30, 35))

        self.uic.showall.setText("Hiển thị toàn bộ")
        self.showalldatabase()


    def setIcon(self, icon_path, ui_element, icon_size=(25, 30)):
            """
            Đặt icon cho một phần tử giao diện PyQt6.

            :param icon_path: Đường dẫn tới tệp hình ảnh cho icon.
            :param ui_element: Phần tử giao diện (ví dụ, nút hoặc QLabel) cần đặt icon.
            :param icon_size: Kích thước của icon (rộng, cao). Mặc định là (25, 30).
            """
            icon = QtGui.QIcon()  # Tạo một đối tượng QIcon
            pixmap = QtGui.QPixmap(icon_path)  # Tạo QPixmap từ đường dẫn hình ảnh
            icon.addPixmap(pixmap, QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)  # Thêm pixmap vào icon

            ui_element.setIcon(icon)  # Đặt icon cho phần tử giao diện
            ui_element.setIconSize(QtCore.QSize(*icon_size))  # Đặt kích thước icon

    def getImageLabel(self,image):
        imageLabel = QtWidgets.QLabel()
        imageLabel.setText("")
        imageLabel.setScaledContents(True)
        pixmap = QtGui.QPixmap()
        pixmap.loadFromData(image, 'jpg')
        imageLabel.setPixmap(pixmap)
        return imageLabel
    
    def showalldatabase(self):
        self.uic.databasetable.clearContents()
        db = mysql.connector.connect(
            user='mobeo2002',
            password='doanquangluu',
            host='localhost',
            database='speed_gun'
        )
        cursor = db.cursor()
        cursor.execute("SELECT * FROM image")  # Select all columns from your table
        rows = cursor.fetchall()
        db.close()
        self.uic.databasetable.setRowCount(len(rows))
        self.uic.databasetable.setStyleSheet("QTableWidget::item { border-bottom: 74px}")
        for i, row in enumerate(rows):
            for j, value in enumerate(row):
                if(j==1):
                    item=self.getImageLabel(value)
                    self.uic.databasetable.setCellWidget(i,j,item)
                elif j == 2:
                    if value == 0:
                        self.uic.databasetable.setItem(i, j, QTableWidgetItem("Từ chối"))
                    else:
                        self.uic.databasetable.setItem(i, j, QTableWidgetItem("Đồng ý"))
                else:
                    self.uic.databasetable.setItem(i, j, QTableWidgetItem(str(value)))

    def exit(self):
        # Thực hiện các hành động bạn muốn khi thoát ứng dụng
        self.close()

    def minimize_window(self):
        # Minimize cửa sổ
        self.showMinimized()

    def maximize_window(self):
        # Maximize hoặc phục hồi cửa sổ
        if self.isMaximized():
            self.setIcon("icon/max2.png", self.uic.maxbuttonsearch, icon_size=(30, 35))
            self.resize(800, 600)
        else:
            self.setIcon("icon/min.png", self.uic.maxbuttonsearch, icon_size=(30, 35))
            self.showMaximized()

    def dialog_config(self, dialog, dialog_text, callback_function):
        dialog.setWindowTitle(dialog_text)
        dialog.resize(300, 50)  # Đặt kích thước cho cửa sổ pop-up

        # Thêm một QLineEdit để nhập giá trị tên vào dialog
        line_edit = QLineEdit(dialog)

        # Thêm một QPushButton vào dialog
        btn_ok = QPushButton('OK', dialog)

        # Bố trí các thành phần trong dialog bằng QVBoxLayout
        layout = QVBoxLayout()
        layout.addWidget(QLabel(dialog_text))
        layout.addWidget(line_edit)
        layout.addWidget(btn_ok)

        # Xử lý sự kiện khi nhấn nút "OK"
        def showValue():
            value = line_edit.text()
            callback_function(value)
            dialog.close()

        btn_ok.clicked.connect(showValue)

        dialog.setLayout(layout)

    def searchbyname(self):
        # Tạo một QDialog để hiển thị pop-up
        dialog = QDialog(self)
        def callback_function(name_value):
            self.databaseshow_partial_column('name', name_value)
        self.dialog_config(dialog, "Tìm kiếm theo tên", callback_function)
        # Hiển thị dialog
        dialog.exec()


    def searchbydate(self):
        dialog = QDialog(self)
        dialog.setWindowTitle("Chọn khoảng ngày tháng")
        dialog.resize(800, 500)
        
        layout = QVBoxLayout()
        
        label_start = QLabel("Chọn ngày bắt đầu:")
        calendar_start = QCalendarWidget(dialog)
        label_end = QLabel("Chọn ngày kết thúc:")
        calendar_end = QCalendarWidget(dialog)
        
        btn_ok = QPushButton('OK', dialog)
        
        layout.addWidget(label_start)
        layout.addWidget(calendar_start)
        layout.addWidget(label_end)
        layout.addWidget(calendar_end)
        layout.addWidget(btn_ok)
        dialog.setLayout(layout)

        def showSelectedDateRange():
            start_date = calendar_start.selectedDate().toString('yyyy-MM-dd')
            end_date = calendar_end.selectedDate().toString('yyyy-MM-dd')
            self.databaseshow_partial_column('date', (start_date, end_date))
            dialog.close()
        btn_ok.clicked.connect(showSelectedDateRange)
        dialog.exec()
        

    def searchbyplate(self):
        # Tạo một QDialog để hiển thị pop-up
        dialog = QDialog(self)
        def callback_function(plate_value):
            self.databaseshow_partial_column('plate', plate_value)
        self.dialog_config(dialog, "Tìm kiếm theo tên", callback_function)
        # Hiển thị dialog
        dialog.exec()

    def searchbylocation(self):
        # Tạo một QDialog để hiển thị pop-up
        dialog = QDialog(self)
        def callback_function(location_value):
            self.databaseshow_partial_column('location', location_value)
        self.dialog_config(dialog, "Tìm kiếm theo vị trí", callback_function)
        # Hiển thị dialog
        dialog.exec()

    def searchbyspeed(self):
        dialog = QDialog(self)
        dialog.setWindowTitle("Tìm kiếm theo khoảng tốc độ")

        # SpinBox để nhập giá trị tốc độ tối thiểu
        min_speed_spinbox = QSpinBox(dialog)
        min_speed_spinbox.setMinimum(0)
        min_speed_spinbox.setMaximum(200)
        min_speed_spinbox.setValue(60)
        min_speed_spinbox.setFixedSize(300, 50)

        # SpinBox để nhập giá trị tốc độ tối đa
        max_speed_spinbox = QSpinBox(dialog)
        max_speed_spinbox.setMinimum(0)
        max_speed_spinbox.setMaximum(200)
        max_speed_spinbox.setValue(100)
        max_speed_spinbox.setFixedSize(300, 50)

        layout = QVBoxLayout()
        layout.addWidget(QLabel("Nhập tốc độ tối thiểu:"))
        layout.addWidget(min_speed_spinbox)
        layout.addWidget(QLabel("Nhập tốc độ tối đa:"))
        layout.addWidget(max_speed_spinbox)

        btn_ok = QPushButton('OK', dialog)
        layout.addWidget(btn_ok)

        def showSpeed():
            min_speed_value = min_speed_spinbox.value()
            max_speed_value = max_speed_spinbox.value()
            self.databaseshow_partial_column('speed', (min_speed_value, max_speed_value))
            dialog.close()

        btn_ok.clicked.connect(showSpeed)
        dialog.setLayout(layout)
        dialog.exec()

    def searchbyid(self):
        dialog = QDialog(self)
        dialog.setWindowTitle("Tìm kiếm theo khoảng ID")
        
        # SpinBox để nhập giá trị ID tối thiểu
        min_id_spinbox = QSpinBox(dialog)
        min_id_spinbox.setMinimum(0)
        min_id_spinbox.setValue(0)
        min_id_spinbox.setFixedSize(300, 50)
        
        # SpinBox để nhập giá trị ID tối đa
        max_id_spinbox = QSpinBox(dialog)
        max_id_spinbox.setMinimum(0)
        max_id_spinbox.setValue(100)
        max_id_spinbox.setFixedSize(300, 50)
        
        layout = QVBoxLayout()
        layout.addWidget(QLabel("Nhập ID tối thiểu:"))
        layout.addWidget(min_id_spinbox)
        layout.addWidget(QLabel("Nhập ID tối đa:"))
        layout.addWidget(max_id_spinbox)
        
        btn_ok = QPushButton('OK', dialog)
        layout.addWidget(btn_ok)
        
        def showIdRange():
            min_id_value = min_id_spinbox.value()
            max_id_value = max_id_spinbox.value()
            self.databaseshow_partial_column('id', (min_id_value, max_id_value))
            dialog.close()
        
        btn_ok.clicked.connect(showIdRange)
        dialog.setLayout(layout)
        dialog.exec()

    def searchbystatus(self):
        # Tạo một QDialog để chọn trạng thái
        dialog = QDialog(self)
        dialog.setWindowTitle("Chọn trạng thái")
        dialog.resize(300, 50)  # Đặt kích cỡ dialog là 300x300
        layout = QVBoxLayout()
        # Tạo nút "Đồng ý"
        btn_agree = QPushButton("Đồng ý", dialog)
        layout.addWidget(btn_agree)
        # Tạo nút "Từ chối"
        btn_decline = QPushButton("Từ chối", dialog)
        layout.addWidget(btn_decline)
        # Xử lý sự kiện khi nhấn nút "Đồng ý"
        def showAcceptedStatus():
            dialog.close()
            self.databaseshow_partial_column('status', 1)
        btn_agree.clicked.connect(showAcceptedStatus)
        # Xử lý sự kiện khi nhấn nút "Từ chối"
        def showDeclinedStatus():
            dialog.close()
            self.databaseshow_partial_column('status', 0)
        btn_decline.clicked.connect(showDeclinedStatus)
        dialog.setLayout(layout)
        # Hiển thị dialog
        dialog.exec()

    def searchbydevice(self):
        # Sử dụng hàm chung với tên cột và tiêu đề thích hợp
        self.search_by_attribute("device", "Tìm kiếm theo thiết bị")

    def searchbyvehicle(self):
        # Sử dụng hàm chung với tên cột và tiêu đề thích hợp
        self.search_by_attribute("vehicle", "Tìm kiếm theo loại phương tiện")

    def search_by_attribute(self, column_name, dialog_title):
        # Kết nối tới cơ sở dữ liệu và truy vấn các giá trị độc nhất
        db = mysql.connector.connect(
            user='mobeo2002',
            password='doanquangluu',
            host='localhost',
            database='speed_gun'
        )
        cursor = db.cursor()

        query = f"SELECT DISTINCT {column_name} FROM image"
        cursor.execute(query)
        distinct_values = [row[0] for row in cursor.fetchall()]

        db.close()

        # Tạo QDialog để kiểm soát kích thước và giao diện
        custom_dialog = QDialog(self)
        custom_dialog.setWindowTitle(dialog_title)  # Tiêu đề dialog
        custom_dialog.resize(300, 100)  # Kích thước mặc định

        layout = QVBoxLayout(custom_dialog)

        # Tạo QComboBox với các giá trị độc nhất
        combo_box = QComboBox()
        combo_box.addItems(distinct_values)
        combo_box.setFixedSize(300, 50)  # Đặt chiều rộng và chiều cao cố định

        # Áp dụng kiểu CSS để tăng kích thước và cỡ chữ
        combo_box.setStyleSheet("""
            QComboBox {
                font-size: 16pt;  # Tăng cỡ chữ
                padding: 10px;  # Thêm khoảng cách
            }
            QComboBox::down-arrow {
                width: 20px;  # Tăng kích thước mũi tên
                height: 20px;
            }
        """)

        layout.addWidget(combo_box)

        # Tạo nút OK và thêm vào bố cục
        ok_button = QPushButton("OK")
        layout.addWidget(ok_button)

        # Kết nối sự kiện cho nút OK
        ok_button.clicked.connect(lambda: custom_dialog.accept())  # Khi nhấn OK

        # Hiển thị dialog
        custom_dialog.exec()

        selected_value = combo_box.currentText()  # Lấy giá trị đã chọn

        if selected_value:
            # Thực hiện hành động dựa trên lựa chọn
            self.databaseshow_partial_column(column_name, selected_value)

    def databaseshow_partial_column(self, column_name, show_value):
        db = mysql.connector.connect(
            user='mobeo2002',
            password='doanquangluu',
            host='localhost',
            database='speed_gun'
        )
        cursor = db.cursor()

        # Kiểm tra nếu show_value là tuple (khoảng giá trị)
        if isinstance(show_value, tuple) and len(show_value) == 2:
            min_value, max_value = show_value
            query = f"SELECT * FROM image WHERE {column_name} BETWEEN %s AND %s"
            cursor.execute(query, (min_value, max_value))
        else:
            # Nếu show_value không phải là tuple, xử lý như trước (chỉ trong trường hợp đặc biệt)
            if isinstance(show_value, str):
                query = f"SELECT * FROM image WHERE {column_name} LIKE %s"
                cursor.execute(query, ("%" + show_value + "%",))
            else:
                query = f"SELECT * FROM image WHERE {column_name} = %s"
                cursor.execute(query, (show_value,))

        rows = cursor.fetchall()
        db.close()

        # Cập nhật table widget với các dòng được trả về từ cơ sở dữ liệu
        self.uic.databasetable.setRowCount(len(rows))
        for i, row in enumerate(rows):
            for j, value in enumerate(row):
                if j == 1:
                    item = self.getImageLabel(value)
                    self.uic.databasetable.setCellWidget(i, j, item)
                elif j == 2:
                    if value == 0:
                        self.uic.databasetable.setItem(i, j, QTableWidgetItem("Từ chối"))
                    else:
                        self.uic.databasetable.setItem(i, j, QTableWidgetItem("Đồng ý"))
                else:
                    self.uic.databasetable.setItem(i, j, QTableWidgetItem(str(value)))

        return show_value

if __name__ == "__main__":
    import sys
    app =QApplication(sys.argv)
    # app = QtWidgets.QApplication(sys.argv)
    # widget=QtWidgets.QStackedWidget()
    w = QtWidgets.QMainWindow()
    ui = MainWindow()
    # Login_f = MainWindow()
    searchUiDef = SearchUI()


    # widget.addWidget(Login_f) 
    # widget.addWidget(search) 
    # widget.setCurrentIndex(0)
    # widget.show()
    # searchUiDef.show()
    sys.exit(app.exec())